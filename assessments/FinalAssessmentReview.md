# AC-iOS Final Assessment

The final will have 3 componenets

# Project

[On github](https://github.com/C4Q/AC-iOS/tree/master/lessons)

- Autolayout
- MVC
- Delegation
- Outlets and Actions
- Table Views
- Segues / Navigation
- Custom TableView Cells
- Lifecycle methods
- JSON Serialization / Codable
- Networking
- Grand Central Dispatch
- UserDefaults
- FileManager
- CollectionViews
- Subclassing UIViews
- Nib/Xib files
- Programmatic view management (Building UI without Storyboard/Xib files)
- Animations
- Mapkit / Core Location
- Gestures
- ScrollViews / Keyboard handling
- Cocoapods
- Firebase
- Core Data
- Testing + Test Driven Development
- OAuth
- Memory Management / Retain Cycles


# Fundamentals

Types:

- Bool
- Int
- Double
- Array
- String
- Character
- Optionals
- Dictionary
- Set
- functions
- closure
- enums
- structs
- classes
- protocols

### Bool 

- Conditionals
- Binary comparison operators (==, !=, >, <, >=, <=)
- Unary negation operator (!)
- Ternary operator (a ? b: c)


### Int 

- Int arithmatic
- Assignment operators (+=, -=, *=, /=, %=)
- Int sizes

### Double

- Double arithmatic
- Converting Ints to Doubles and Doubles to Ints
- Floating point errors

### Array 

- Iterate over the values in an array
- Iterate over the indicies in an array and access the values
- Access an specific element
- Insert and append elements
- Remove elements
- Create an empty array
- Create an array with a repeating value
- Arrays can only store objects of the same type
- contains(_:)
- reversed()


### String and Character

- Iterate over the characters in a String
- Create a String using Unicode Scalars
- Access a specific character
- Insert and remove Characters in a String
- Terminator and Separator
- lowerCased()
- upperCased()
- contains(_:)
- components(separatedBy:_)



### Optionals

- Can either be nil or a value
- Implicitly unwrapped optionals
- Force unwrapping
- Unwrapping with if let
- Unwrapping with guard let
- Unwrapping with the nil-coalescing operator
- Testing optionals for equality
- Optional chaining

### Dictionary

- Map keys to values
- Understand what types are accepted as keys
- Access and unwrap a value for a given key
- Create a value for a given key
- Remove a value for a given key
- Iterate through the (key, value) pairs
- Create a frequency dictionary


### Set

- Remove duplicates from data
- Insert and remove elements
- Check for containment
- Use set operations

### Functions

- Follow the steps of function solving (clarify, signiture, diagram, code, test and refactor)
- Refer to functions by their signature
- Functions with multiple returns
- Understand that a call to a function **is** what it returns
- Functions with default parameter values
- Functions with optionals

### Closures

- Create a closure using long-form notation
- Create a closure using shorthand notation
- Use a closure as a type which can be stored and manipulated
- Closures are reference types
- Write functions that take closures as input
- Write functions that output closures
- Use map, filter, reduce and sort to solve problems and understand how the closure works through the collection

### enums

- Create an enum with cases
- Give cases a raw value
- Give cases Implicitly Assigned Raw Values
- Give cases associated values
- Access raw values
- Access associated values

### structs

- Value type
- Define a struct with properties
- Make an instance of a struct using the default memberwise initializer
- Create and use a custom initializer
- Define type (i.e static) properties
- Define instance methods
- Define type methods
- Create property observers

### classes

- Reference type
- Define a class with properties
- Make an instance of a struct using the default memberwise initializer
- Create and use a custom initializer
- Define type (i.e static) properties
- Define instance methods
- Define type methods
- Create property observers

### protocols

- Defining protocols
- Using protocols for custom delegation

# Data Structure and Algorithms

[On github](https://github.com/C4Q/AC-iOS/tree/master/lessons/dsa)

- Big O Notation
- Arrays
- Linked Lists
- Hashmaps
- Queues
- Stacks
- Recursion
- Sorting Algorithms
- Trees
- Graphs
- Whiteboarding questions

### Big O Notation

- Explain the runtime of functions
- Rank runtimes relative to each other

### Arrays

- Explain how arrays are stored in memory
- Explain the runtimes for access, find, insert delete
- Give examples of when data is best modeled using an array


### Linked Lists

- Explain how linked lists are stored in memory
- Explain the runtimes for access, find, insert delete
- Give examples of when data is best modeled using a linked list

### Hashmaps

- Explain how hashmaps are stored in memory
- Explain the runtimes for access, find, insert delete
- Give examples of when data is best modeled using a hashmap


### Stacks

- Explain how a Stack can be implemented using an array
- Explain how a Stack can be implemented using a linked list
- Explain the runtimes for access, find, insert delete

### Queues

- Explain how a Queue can be implemented using a linked list
- Explain the runtimes for access, find, insert delete
- Give examples of when data is best modeled using a queue

### Recursion

- Explain what a base case is and what happens if you don't have one
- Explain why recursion can be a useful way to solve problems
- Solve problems using recursion (e.g multiply two numbers without using "*")

### Sorting Algorithms

- Explain how bubble sort and insertion sort work (n<sup>2</sup> sorts) 
- Explain how merge sort and quicksort work (nlog<sub>2</sub>(n) sorts)
- Determine what inputs to a sorting function will give it the worst case and best case runtimes

### Trees

- Traverse a tree using a breadth first search (bfs)
- Traverse a tree using a depth first search (dfs)
- Explain the runtimes for accessing, searching, inserting, and deleting elements into a binary search tree (BST)
- Give examples of when data is best modeled using a tree

### Graphs

- Explain the difference between weighted, unweighted, directed and undirected graphs
- Give examples of when data is best modeled using a graph

### Whiteboarding Questions

- Solve whiteboarding problems
